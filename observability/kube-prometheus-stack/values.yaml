kube-prometheus-stack:
  crds:
    enabled: true
  cleanPrometheusOperatorObjectNames: true
  alertmanager:
    enabled: true
    config:
      # enabled: true
      global:
        resolve_timeout: 5m
      route:
        group_by: [ 'alertname', 'job' ]
        group_wait: 45s
        group_interval: 10m
        repeat_interval: 12h
        receiver: "msteams"
        routes:
        - receiver: "null" # quote
          matchers:
          - alertname =~ "Watchdog"
        - receiver: "null" # quote
          matchers:
          - alertname =~ "InfoInhibitor"
        - receiver: "msteams"
          match:
            severity: critical
          continue: true
        - receiver: "msteams"
      inhibit_rules:
      - source_matchers:
        - severity = "critical"
        target_matchers:
        - severity = "warning"
        equal: [ "alertname", "namespace" ]
      - target_match_re:
          alertname: '.+Overcommit'
        source_match:
          alertname: 'Watchdog'
        equal: [ 'prometheus' ]
      receivers:
      - name: "null"
      - name: "msteams"
        msteams_configs:
        - send_resolved: true
          webhook_url: 'https://dorilton.webhook.office.com/webhookb2/1addc0a5-fcb6-4dd8-9c33-c7ab0754a210@21cbdbad-6e79-46a0-b3f3-3a7f62554acc/IncomingWebhook/2a2ef1fc676541d18e10af8bad086536/a6a90eee-9e69-4489-8b9c-39d505478da4/V2SQac6Y7SRSH3A3963qMzTHNEylf2fp2tiJJyVfdtqHg1'
          title: |-
            ðŸš¨ [{{ .Status | toUpper }}{{ if eq .Status "firing" }}:{{ .Alerts.Firing | len }}{{ end }}] 
            (Cluster: {{ .CommonLabels.cluster }})

            **ðŸ“¢ Alert Notification - Kosmos Alerts Monitoring**

            {{ if eq .Status "firing" }}ðŸ”¥ **Action Required Immediately!** ðŸ”¥{{ else }}âœ… **Issue Resolved** âœ…{{ end }}

          text: |-
            **ðŸ”” Alert Details:**
            {{ range $index, $alert := .Alerts -}}{{ if $index }}---{{ end }}
            {{ if $alert.Labels.alertname }}
            **ðŸ†˜ Alert Name**: {{ $alert.Labels.alertname }}
            {{ end }}

            **ðŸ›‘ Labels:**
            {{ if $alert.Labels.severity }}
            - **Severity**: {{ $alert.Labels.severity }}
            {{ end }}
            {{ if $alert.Labels.instance }}
            - **Instance**: {{ $alert.Labels.instance }}
            {{ end }}
            {{ if $alert.Labels.namespace }}
            - **Namespace**: {{ $alert.Labels.namespace }}
            {{ end }}
            {{ if $alert.Labels.pod }}
            - **Pod**: {{ $alert.Labels.pod }}
            {{ end }}

            **ðŸ“„ Annotations:**
            {{ if $alert.Annotations.description }}
            - **Description**: {{ $alert.Annotations.description }}
            {{ end }}
            {{ if $alert.Annotations.summary }}
            - **Summary**: {{ $alert.Annotations.summary }}
            {{ end }}

            {{ if $alert.GeneratorURL }}
            ðŸ”— **Source**: [View in AlertManager]({{ $alert.GeneratorURL }})
            {{ end }}

            **ðŸ“Œ Additional Notes:**
            - Ensure the affected service is reviewed immediately.
            - Escalate to the **on-call team** if required.
            - Check related metrics and logs for further debugging.

            {{ end }}
    alertmanagerSpec:
      replicas: 3
      podAntiAffinity: hard
      storage:
        volumeClaimTemplate:
          spec:
            storageClassName: ebs-sc
            resources:
              requests:
                storage: 10Gi
      # tolerations:
      # - key: "arm64"
      #   operator: "Exists"
  prometheusOperator:
    admissionWebhooks:
      enabled: true

      annotations:
        argocd.argoproj.io/hook: PreSync
        argocd.argoproj.io/hook-delete-policy: HookSucceeded

      patch:
        annotations:
          argocd.argoproj.io/hook: PreSync
          argocd.argoproj.io/hook-delete-policy: HookSucceeded

      mutatingWebhookConfiguration:
        annotations:
          argocd.argoproj.io/hook: PreSync

      validatingWebhookConfiguration:
        annotations:
          argocd.argoproj.io/hook: PreSync
  kubelet:
    enabled: true
    serviceMonitor:
      metricRelabelings:
      # Drop high cardinality labels
      - action: labeldrop
        regex: (uid)
      - action: labeldrop
        regex: (id|name)
      - action: drop
        sourceLabels: [ "__name__" ]
        regex: (rest_client_request_duration_seconds_bucket|rest_client_request_duration_seconds_sum|rest_client_request_duration_seconds_count)
  kubeApiServer:
    enabled: true
    serviceMonitor:
      metricRelabelings:
      # Drop high cardinality labels
      - action: drop
        sourceLabels: [ "__name__" ]
        regex: (apiserver|etcd|rest_client)_request(|_sli|_slo)_duration_seconds_bucket
      - action: drop
        sourceLabels: [ "__name__" ]
        regex: (apiserver_response_sizes_bucket|apiserver_watch_events_sizes_bucket)
  kubeControllerManager:
    enabled: true
    # endpoints: &cp
    #   - 10.69.3.26
  kubeEtcd:
    enabled: true
    # endpoints: *cp
  kubeScheduler:
    enabled: true
    # endpoints: *cp
  kubeProxy:
    enabled: false
  prometheus:
    ingress:
      enabled: false
      ingressClassName: internal
      hosts: [ "prometheus.${SECRET_DOMAIN}" ]
      pathType: Prefix
    thanosService:
      enabled: false
    thanosServiceMonitor:
      enabled: false
    prometheusSpec:
      replicas: 2
      replicaExternalLabelName: __replica__
      scrapeInterval: 1m # Must match interval in Grafana Helm chart
      ruleSelectorNilUsesHelmValues: false
      serviceMonitorSelectorNilUsesHelmValues: false
      podMonitorSelectorNilUsesHelmValues: false
      probeSelectorNilUsesHelmValues: false
      scrapeConfigSelectorNilUsesHelmValues: false
      enableAdminAPI: true
      walCompression: true
      enableFeatures:
      - auto-gomemlimit
      - memory-snapshot-on-shutdown
      - new-service-discovery-manager
      enableRemoteWriteReceiver: true
      retention: 14d
      retentionSize: 15GB
      externalLabels:
        cluster: apps
      resources:
        requests:
          cpu: 100m
        limits:
          memory: 1500Mi
      storageSpec:
        volumeClaimTemplate:
          spec:
            storageClassName: ebs-sc
            resources:
              requests:
                storage: 60Gi
      remoteWrite:
      - url: "http://thanos-receive:19291/api/v1/receive"
        name: thanos-receiver
        # enableHttp2: true
      additionalRulesForClusterRole:
      - apiGroups: [ "" ]
        resources: [ "services/k6-operator-controller-manager-metrics-service" ]
        verbs: [ "get", "list", "watch" ]
  nodeExporter:
    enabled: true
  prometheus-node-exporter:
    fullnameOverride: node-exporter
    prometheus:
      monitor:
        enabled: true
        relabelings:
        - action: replace
          regex: (.*)
          replacement: $1
          sourceLabels: [ "__meta_kubernetes_pod_node_name" ]
          targetLabel: kubernetes_node
  kubeStateMetrics:
    enabled: true
  kube-state-metrics:
    fullnameOverride: kube-state-metrics
    metricLabelsAllowlist:
    - pods=[*]
    - deployments=[*]
    - persistentvolumeclaims=[*]
    prometheus:
      monitor:
        enabled: true
        relabelings:
        - action: replace
          regex: (.*)
          replacement: $1
          sourceLabels: [ "__meta_kubernetes_pod_node_name" ]
          targetLabel: kubernetes_node
  grafana:
    enabled: false
    forceDeployDashboards: true
    sidecar:
      dashboards:
        annotations:
          grafana_folder: Kubernetes
          home_ops: Kubernetes
        multicluster:
          etcd:
            enabled: true
